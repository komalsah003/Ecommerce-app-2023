declare type ExtendedPromiseOptions = {
    onResolve?: Function;
    onReject?: Function;
    suppressUnhandledPromiseMessage?: boolean;
};
declare type PromiseFunction = {
    (resolve: (value?: unknown) => void, reject: (reason?: unknown) => void): void;
};
interface PromiseModel {
    new (f: PromiseFunction): any;
    all: Function;
    allSettled?: Function;
    race: Function;
    resolve: Function;
    reject: Function;
}
declare type PromiseInstance = {
    then: Function;
    catch: Function;
};
declare class ExtendedPromise {
    static Promise: PromiseModel;
    static suppressUnhandledPromiseMessage: boolean;
    static defaultOnResolve(result: unknown): PromiseModel;
    static defaultOnReject(err: Error): PromiseModel;
    static setPromise(PromiseClass: typeof Promise): void;
    static shouldCatchExceptions(options: ExtendedPromiseOptions): boolean;
    static all(args: unknown[]): PromiseModel;
    static allSettled(args: unknown[]): PromiseModel;
    static race(args: unknown[]): PromiseModel;
    static reject(arg?: Error): PromiseModel;
    static resolve(arg?: unknown): PromiseModel;
    isFulfilled: boolean;
    isResolved: boolean;
    isRejected: boolean;
    _promise: PromiseInstance;
    _onResolve: Function;
    _onReject: Function;
    _resolveFunction: Function;
    _rejectFunction: Function;
    constructor(options?: ExtendedPromiseOptions | PromiseFunction);
    then(...args: unknown[]): PromiseInstance;
    catch(...args: unknown[]): PromiseInstance;
    resolve(arg?: unknown): ExtendedPromise;
    reject(arg?: unknown): ExtendedPromise;
    _resetState(): void;
    _setResolved(): void;
    _setRejected(): void;
}
export = ExtendedPromise;
